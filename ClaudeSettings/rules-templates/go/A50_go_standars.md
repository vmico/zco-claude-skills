# Go 项目编程标准 (zco-optimized)

## 1. 注释协议 (AI 强识别)

利用特殊前缀将**代码指令**从**解释文本**中分离。

* **`//` (标准注释)**: 仅用于导出的 API 文档注释（英文为主）。
* **`//;` (业务说明)**: ✅ **必须**。使用自然语言解释复杂的“为什么”。
* **`//;@` (动作标记)**: ✅ **必须**。AI 触发器，如 `//;@TODO`, `//;@FIXME`, `//;@NOTE`。
* ❌ **禁止**: 严禁使用普通 `//` 编写长篇中文业务逻辑，必须升级为 `//;` 以便 AI 区分代码片段与解释。

---

## 2. 命名与结构规范

### 2.1 基础原则

* **包名**: 单个短小单词（`user`, `auth`），❌ 严禁下划线或驼峰（以及中划线、大写字母）。
* **接口名**: 
* ✅ 单方法接口：后缀必须是 er。例如：type Syncer interface { Sync() error }。
* ✅ 多方法接口：通常使用名词。例如：type UserRepository interface（包含 Create, Update, Delete 等）。
* **缩写**: 必须全大写或全小写（`userID` 或 `UserID`, ❌ 严禁 `UserId`）。

### 2.2 零值可用 (Design Rule)

* ✅ **推荐**: 结构体应设计为“零值可用”，避免不必要的初始化检查。
```go
var s sync.Mutex // 直接可用，无需 New

```

---

## 3. 代码组织与分层

### 3.1 严格分层

* ✅ **链路**: `handler -> service -> repository`。
* ❌ **禁止**: 严禁 Repository 层直接返回数据库原生 Error 给 Handler，必须在 Service 层进行业务错误转换。
* ✅ **Context 传递**: 所有涉及 IO 或跨层调用的函数，第一个参数 **必须** 是 `ctx context.Context`。

---

## 4. 错误处理 (The Go Way)

### 4.1 包装与判定

* ✅ **包装**: 使用 `fmt.Errorf("...: %w", err)` 注入上下文。
* ✅ **判定**: 严禁使用 `err.Error() == "..."`。必须使用 `errors.Is()` 或 `errors.As()`。
* ✅ **及早返回**: 减少 `else` 嵌套，错误处理应在 4 个空格缩进内完成。

---

## 5. 并发安全约束

* ✅ **生命周期**: 启动 Goroutine 时，必须明确它何时结束。
* ✅ **Channel**: 发送方负责关闭，接收方通过 `v, ok := <-ch` 判定关闭。
* ✅ **Mutex**: 必须紧跟 `Lock()` 后使用 `defer Unlock()`。
* ❌ **禁止**: 在持有锁的情况下调用外部插件或进行网络 IO。

---

## 6. 函数与工程质量

* 📏 **函数体**: 建议 **≤ 50 行**。超过则必须重构。
* 🔢 **参数**: 超过 3 个参数强制使用 `Option` 模式或 `Request` 结构体。
* 🧪 **测试**: 必须使用 **Table-Driven Tests (表驱动测试)**。
* 📈 **覆盖率**: 核心逻辑 **≥ 90%**，工具类 **≥ 80%**。

---

## 7. 工具集成 (强制)

提交 PR 前必须在本地运行：

1. `go fmt ./...`
2. `go mod tidy`
3. `golangci-lint run` (配置 `funlen` 和 `gocyclo` 约束)。

